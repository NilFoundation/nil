package rpctest

import (
	"crypto/ecdsa"
	"math/big"
	"testing"

	"github.com/NilFoundation/nil/nil/common"
	"github.com/NilFoundation/nil/nil/internal/contracts"
	"github.com/NilFoundation/nil/nil/internal/types"
	"github.com/NilFoundation/nil/nil/services/nilservice"
	"github.com/NilFoundation/nil/nil/services/rpc"
	"github.com/NilFoundation/nil/nil/services/rpc/transport"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/holiman/uint256"
	"github.com/rs/zerolog/log"
	"github.com/stretchr/testify/suite"
)

type SuiteFaucet struct {
	RpcSuite
}

func (s *SuiteFaucet) SetupTest() {
	s.start(&nilservice.Config{
		NShards: 5,
		HttpUrl: rpc.GetSockPath(s.T()),
		RunMode: nilservice.CollatorsOnlyRunMode,
	})
}

func (s *SuiteFaucet) TearDownTest() {
	s.cancel()
}

func (s *SuiteFaucet) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	s.T().Helper()

	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := uint256.NewInt(123).Bytes32()
	callData, err := contracts.NewCallData(contracts.NameFaucet, "createWallet", ownerPublicKey, salt, big.NewInt(value))
	s.Require().NoError(err)

	resHash, err := s.client.SendExternalMessage(callData, types.FaucetAddress, nil, types.Value{})
	s.Require().NoError(err)

	res := s.waitForReceipt(types.BaseShardId, resHash)
	s.Require().True(res.Success)

	// Checking whether the address generated by CREATE2 matches the expected one
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(types.FaucetAddress, walletCode, salt)
	s.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (s *SuiteFaucet) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	s.Require().NoError(err)

	var value int64 = 100000
	walletAddress := s.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := s.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	s.Require().NoError(err)

	s.Require().NoError(err)
	s.Require().Equal(uint64(value), balance.Uint64())
}

func (s *SuiteFaucet) TestDeployContractViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	s.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	value := types.NewValueFromUint64(123_456_789)
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(userPublicKey)

	code := types.BuildDeployPayload(walletCode, common.EmptyHash)
	walletAddr := types.CreateAddress(types.FaucetAddress.ShardId(), code)
	msgHash, err := s.client.TopUpViaFaucet(walletAddr, value)
	s.Require().NoError(err)
	receipt := s.waitForReceipt(walletAddr.ShardId(), msgHash)
	s.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		s.Require().True(r.Success)
	}

	msgHash, receiptContractAddress, err := s.client.DeployExternal(walletAddr.ShardId(), code, types.GasToValue(100_000))
	s.Require().NoError(err)
	s.Require().Equal(walletAddr, receiptContractAddress)
	receipt = s.waitForReceipt(walletAddr.ShardId(), msgHash)
	s.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		s.Require().True(r.Success)
	}

	balance, err := s.client.GetBalance(walletAddr, "latest")
	s.Require().NoError(err)
	s.Require().Less(balance.Uint64(), value.Uint64())
	s.Require().Positive(balance.Uint64())
	log.Logger.Info().Msgf("Spent %s nil", value.Sub(balance))
}

func (s *SuiteFaucet) TestTopUpViaFaucet() {
	pk, err := crypto.GenerateKey()
	s.Require().NoError(err)
	pubKey := crypto.CompressPubkey(&pk.PublicKey)
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(pubKey)

	address, receipt := s.deployContractViaMainWallet(types.BaseShardId, types.BuildDeployPayload(walletCode, common.EmptyHash), types.Value{})
	receipt = s.waitForReceipt(types.MainWalletAddress.ShardId(), receipt.MsgHash)
	s.Require().NotNil(receipt)
	s.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		s.Require().True(r.Success)
	}

	testTopUp := func(initialValue, value, expectedValue uint64, delta float64) {
		balance, err := s.client.GetBalance(address, transport.LatestBlockNumber)
		s.Require().NoError(err)
		s.Require().Equal(initialValue, balance.Uint64())

		code, err := s.client.GetCode(address, transport.LatestBlockNumber)
		s.Require().NoError(err)
		s.Require().NotEmpty(code)

		mshHash, err := s.client.TopUpViaFaucet(address, types.NewValueFromUint64(value))
		s.Require().NoError(err)
		receipt = s.waitForReceipt(address.ShardId(), mshHash)
		s.Require().NotNil(receipt)
		s.Require().True(receipt.Success)
		for _, r := range receipt.OutReceipts {
			s.Require().True(r.Success)
		}

		balance, err = s.client.GetBalance(address, transport.LatestBlockNumber)
		s.Require().NoError(err)
		s.Require().InDelta(expectedValue, balance.Uint64(), delta)
	}

	var value1 uint64 = 5 * 1_000_000_000_000_000
	balance1 := value1
	s.Run("Top up for the first time without exceeding the limit", func() {
		testTopUp(0, value1, balance1, 0)
	})

	var value2 uint64 = 4 * 1_000_000_000_000_000
	balance2 := balance1 + value2
	s.Run("Top up for the second time without exceeding the limit", func() {
		testTopUp(balance1, value2, balance2, 0)
	})

	// this test is quite flaky, cause it checks
	// functionality that depends on block generation speed
	var value3 uint64 = 5 * 1_000_000_000_000_000
	var balance3 uint64 = 10_000_000_000_000_000
	s.Run("Top up over limit", func() {
		testTopUp(balance2, value3, balance3, float64(balance3)*0.2)
	})
}

func TestSuiteFaucet(t *testing.T) {
	t.Parallel()

	suite.Run(t, new(SuiteFaucet))
}
