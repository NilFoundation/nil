// Code generated by mockery v2.53.3. DO NOT EDIT.

//go:build test

package client

import (
	context "context"

	common "github.com/NilFoundation/nil/nil/common"

	db "github.com/NilFoundation/nil/nil/internal/db"

	ecdsa "crypto/ecdsa"

	internaltypes "github.com/NilFoundation/nil/nil/internal/types"

	json "encoding/json"

	jsonrpc "github.com/NilFoundation/nil/nil/services/rpc/jsonrpc"

	mock "github.com/stretchr/testify/mock"

	types "github.com/NilFoundation/nil/nil/services/rpc/types"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// BatchCall provides a mock function with given fields: ctx, req
func (_m *MockClient) BatchCall(ctx context.Context, req BatchRequest) ([]interface{}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for BatchCall")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, BatchRequest) ([]interface{}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, BatchRequest) []interface{}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, BatchRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_BatchCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchCall'
type MockClient_BatchCall_Call struct {
	*mock.Call
}

// BatchCall is a helper method to define mock.On call
//   - ctx context.Context
//   - req BatchRequest
func (_e *MockClient_Expecter) BatchCall(ctx interface{}, req interface{}) *MockClient_BatchCall_Call {
	return &MockClient_BatchCall_Call{Call: _e.mock.On("BatchCall", ctx, req)}
}

func (_c *MockClient_BatchCall_Call) Run(run func(ctx context.Context, req BatchRequest)) *MockClient_BatchCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(BatchRequest))
	})
	return _c
}

func (_c *MockClient_BatchCall_Call) Return(_a0 []interface{}, _a1 error) *MockClient_BatchCall_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_BatchCall_Call) RunAndReturn(run func(context.Context, BatchRequest) ([]interface{}, error)) *MockClient_BatchCall_Call {
	_c.Call.Return(run)
	return _c
}

// Call provides a mock function with given fields: ctx, args, blockId, stateOverride
func (_m *MockClient) Call(ctx context.Context, args *types.CallArgs, blockId interface{}, stateOverride *types.StateOverrides) (*jsonrpc.CallRes, error) {
	ret := _m.Called(ctx, args, blockId, stateOverride)

	if len(ret) == 0 {
		panic("no return value specified for Call")
	}

	var r0 *jsonrpc.CallRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CallArgs, interface{}, *types.StateOverrides) (*jsonrpc.CallRes, error)); ok {
		return rf(ctx, args, blockId, stateOverride)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CallArgs, interface{}, *types.StateOverrides) *jsonrpc.CallRes); ok {
		r0 = rf(ctx, args, blockId, stateOverride)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.CallRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CallArgs, interface{}, *types.StateOverrides) error); ok {
		r1 = rf(ctx, args, blockId, stateOverride)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Call_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Call'
type MockClient_Call_Call struct {
	*mock.Call
}

// Call is a helper method to define mock.On call
//   - ctx context.Context
//   - args *types.CallArgs
//   - blockId interface{}
//   - stateOverride *types.StateOverrides
func (_e *MockClient_Expecter) Call(ctx interface{}, args interface{}, blockId interface{}, stateOverride interface{}) *MockClient_Call_Call {
	return &MockClient_Call_Call{Call: _e.mock.On("Call", ctx, args, blockId, stateOverride)}
}

func (_c *MockClient_Call_Call) Run(run func(ctx context.Context, args *types.CallArgs, blockId interface{}, stateOverride *types.StateOverrides)) *MockClient_Call_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.CallArgs), args[2].(interface{}), args[3].(*types.StateOverrides))
	})
	return _c
}

func (_c *MockClient_Call_Call) Return(_a0 *jsonrpc.CallRes, _a1 error) *MockClient_Call_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Call_Call) RunAndReturn(run func(context.Context, *types.CallArgs, interface{}, *types.StateOverrides) (*jsonrpc.CallRes, error)) *MockClient_Call_Call {
	_c.Call.Return(run)
	return _c
}

// ChainId provides a mock function with given fields: ctx
func (_m *MockClient) ChainId(ctx context.Context) (internaltypes.ChainId, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 internaltypes.ChainId
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (internaltypes.ChainId, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) internaltypes.ChainId); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(internaltypes.ChainId)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainId'
type MockClient_ChainId_Call struct {
	*mock.Call
}

// ChainId is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) ChainId(ctx interface{}) *MockClient_ChainId_Call {
	return &MockClient_ChainId_Call{Call: _e.mock.On("ChainId", ctx)}
}

func (_c *MockClient_ChainId_Call) Run(run func(ctx context.Context)) *MockClient_ChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_ChainId_Call) Return(_a0 internaltypes.ChainId, _a1 error) *MockClient_ChainId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ChainId_Call) RunAndReturn(run func(context.Context) (internaltypes.ChainId, error)) *MockClient_ChainId_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeTokenAmount provides a mock function with given fields: ctx, contractAddr, amount, pk, mint
func (_m *MockClient) ChangeTokenAmount(ctx context.Context, contractAddr internaltypes.Address, amount internaltypes.Value, pk *ecdsa.PrivateKey, mint bool) (common.Hash, error) {
	ret := _m.Called(ctx, contractAddr, amount, pk, mint)

	if len(ret) == 0 {
		panic("no return value specified for ChangeTokenAmount")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, internaltypes.Value, *ecdsa.PrivateKey, bool) (common.Hash, error)); ok {
		return rf(ctx, contractAddr, amount, pk, mint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, internaltypes.Value, *ecdsa.PrivateKey, bool) common.Hash); ok {
		r0 = rf(ctx, contractAddr, amount, pk, mint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, internaltypes.Value, *ecdsa.PrivateKey, bool) error); ok {
		r1 = rf(ctx, contractAddr, amount, pk, mint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ChangeTokenAmount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeTokenAmount'
type MockClient_ChangeTokenAmount_Call struct {
	*mock.Call
}

// ChangeTokenAmount is a helper method to define mock.On call
//   - ctx context.Context
//   - contractAddr internaltypes.Address
//   - amount internaltypes.Value
//   - pk *ecdsa.PrivateKey
//   - mint bool
func (_e *MockClient_Expecter) ChangeTokenAmount(ctx interface{}, contractAddr interface{}, amount interface{}, pk interface{}, mint interface{}) *MockClient_ChangeTokenAmount_Call {
	return &MockClient_ChangeTokenAmount_Call{Call: _e.mock.On("ChangeTokenAmount", ctx, contractAddr, amount, pk, mint)}
}

func (_c *MockClient_ChangeTokenAmount_Call) Run(run func(ctx context.Context, contractAddr internaltypes.Address, amount internaltypes.Value, pk *ecdsa.PrivateKey, mint bool)) *MockClient_ChangeTokenAmount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(internaltypes.Value), args[3].(*ecdsa.PrivateKey), args[4].(bool))
	})
	return _c
}

func (_c *MockClient_ChangeTokenAmount_Call) Return(_a0 common.Hash, _a1 error) *MockClient_ChangeTokenAmount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ChangeTokenAmount_Call) RunAndReturn(run func(context.Context, internaltypes.Address, internaltypes.Value, *ecdsa.PrivateKey, bool) (common.Hash, error)) *MockClient_ChangeTokenAmount_Call {
	_c.Call.Return(run)
	return _c
}

// ClientVersion provides a mock function with given fields: ctx
func (_m *MockClient) ClientVersion(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ClientVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientVersion'
type MockClient_ClientVersion_Call struct {
	*mock.Call
}

// ClientVersion is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) ClientVersion(ctx interface{}) *MockClient_ClientVersion_Call {
	return &MockClient_ClientVersion_Call{Call: _e.mock.On("ClientVersion", ctx)}
}

func (_c *MockClient_ClientVersion_Call) Run(run func(ctx context.Context)) *MockClient_ClientVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_ClientVersion_Call) Return(_a0 string, _a1 error) *MockClient_ClientVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ClientVersion_Call) RunAndReturn(run func(context.Context) (string, error)) *MockClient_ClientVersion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchRequest provides a mock function with no fields
func (_m *MockClient) CreateBatchRequest() BatchRequest {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchRequest")
	}

	var r0 BatchRequest
	if rf, ok := ret.Get(0).(func() BatchRequest); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(BatchRequest)
		}
	}

	return r0
}

// MockClient_CreateBatchRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchRequest'
type MockClient_CreateBatchRequest_Call struct {
	*mock.Call
}

// CreateBatchRequest is a helper method to define mock.On call
func (_e *MockClient_Expecter) CreateBatchRequest() *MockClient_CreateBatchRequest_Call {
	return &MockClient_CreateBatchRequest_Call{Call: _e.mock.On("CreateBatchRequest")}
}

func (_c *MockClient_CreateBatchRequest_Call) Run(run func()) *MockClient_CreateBatchRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_CreateBatchRequest_Call) Return(_a0 BatchRequest) *MockClient_CreateBatchRequest_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateBatchRequest_Call) RunAndReturn(run func() BatchRequest) *MockClient_CreateBatchRequest_Call {
	_c.Call.Return(run)
	return _c
}

// DbExists provides a mock function with given fields: ctx, tableName, key
func (_m *MockClient) DbExists(ctx context.Context, tableName db.TableName, key []byte) (bool, error) {
	ret := _m.Called(ctx, tableName, key)

	if len(ret) == 0 {
		panic("no return value specified for DbExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.TableName, []byte) (bool, error)); ok {
		return rf(ctx, tableName, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.TableName, []byte) bool); ok {
		r0 = rf(ctx, tableName, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.TableName, []byte) error); ok {
		r1 = rf(ctx, tableName, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DbExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbExists'
type MockClient_DbExists_Call struct {
	*mock.Call
}

// DbExists is a helper method to define mock.On call
//   - ctx context.Context
//   - tableName db.TableName
//   - key []byte
func (_e *MockClient_Expecter) DbExists(ctx interface{}, tableName interface{}, key interface{}) *MockClient_DbExists_Call {
	return &MockClient_DbExists_Call{Call: _e.mock.On("DbExists", ctx, tableName, key)}
}

func (_c *MockClient_DbExists_Call) Run(run func(ctx context.Context, tableName db.TableName, key []byte)) *MockClient_DbExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.TableName), args[2].([]byte))
	})
	return _c
}

func (_c *MockClient_DbExists_Call) Return(_a0 bool, _a1 error) *MockClient_DbExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DbExists_Call) RunAndReturn(run func(context.Context, db.TableName, []byte) (bool, error)) *MockClient_DbExists_Call {
	_c.Call.Return(run)
	return _c
}

// DbExistsInShard provides a mock function with given fields: ctx, shardId, tableName, key
func (_m *MockClient) DbExistsInShard(ctx context.Context, shardId internaltypes.ShardId, tableName db.ShardedTableName, key []byte) (bool, error) {
	ret := _m.Called(ctx, shardId, tableName, key)

	if len(ret) == 0 {
		panic("no return value specified for DbExistsInShard")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) (bool, error)); ok {
		return rf(ctx, shardId, tableName, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) bool); ok {
		r0 = rf(ctx, shardId, tableName, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) error); ok {
		r1 = rf(ctx, shardId, tableName, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DbExistsInShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbExistsInShard'
type MockClient_DbExistsInShard_Call struct {
	*mock.Call
}

// DbExistsInShard is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - tableName db.ShardedTableName
//   - key []byte
func (_e *MockClient_Expecter) DbExistsInShard(ctx interface{}, shardId interface{}, tableName interface{}, key interface{}) *MockClient_DbExistsInShard_Call {
	return &MockClient_DbExistsInShard_Call{Call: _e.mock.On("DbExistsInShard", ctx, shardId, tableName, key)}
}

func (_c *MockClient_DbExistsInShard_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, tableName db.ShardedTableName, key []byte)) *MockClient_DbExistsInShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(db.ShardedTableName), args[3].([]byte))
	})
	return _c
}

func (_c *MockClient_DbExistsInShard_Call) Return(_a0 bool, _a1 error) *MockClient_DbExistsInShard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DbExistsInShard_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) (bool, error)) *MockClient_DbExistsInShard_Call {
	_c.Call.Return(run)
	return _c
}

// DbGet provides a mock function with given fields: ctx, tableName, key
func (_m *MockClient) DbGet(ctx context.Context, tableName db.TableName, key []byte) ([]byte, error) {
	ret := _m.Called(ctx, tableName, key)

	if len(ret) == 0 {
		panic("no return value specified for DbGet")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, db.TableName, []byte) ([]byte, error)); ok {
		return rf(ctx, tableName, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, db.TableName, []byte) []byte); ok {
		r0 = rf(ctx, tableName, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, db.TableName, []byte) error); ok {
		r1 = rf(ctx, tableName, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DbGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbGet'
type MockClient_DbGet_Call struct {
	*mock.Call
}

// DbGet is a helper method to define mock.On call
//   - ctx context.Context
//   - tableName db.TableName
//   - key []byte
func (_e *MockClient_Expecter) DbGet(ctx interface{}, tableName interface{}, key interface{}) *MockClient_DbGet_Call {
	return &MockClient_DbGet_Call{Call: _e.mock.On("DbGet", ctx, tableName, key)}
}

func (_c *MockClient_DbGet_Call) Run(run func(ctx context.Context, tableName db.TableName, key []byte)) *MockClient_DbGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.TableName), args[2].([]byte))
	})
	return _c
}

func (_c *MockClient_DbGet_Call) Return(_a0 []byte, _a1 error) *MockClient_DbGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DbGet_Call) RunAndReturn(run func(context.Context, db.TableName, []byte) ([]byte, error)) *MockClient_DbGet_Call {
	_c.Call.Return(run)
	return _c
}

// DbGetFromShard provides a mock function with given fields: ctx, shardId, tableName, key
func (_m *MockClient) DbGetFromShard(ctx context.Context, shardId internaltypes.ShardId, tableName db.ShardedTableName, key []byte) ([]byte, error) {
	ret := _m.Called(ctx, shardId, tableName, key)

	if len(ret) == 0 {
		panic("no return value specified for DbGetFromShard")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) ([]byte, error)); ok {
		return rf(ctx, shardId, tableName, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) []byte); ok {
		r0 = rf(ctx, shardId, tableName, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) error); ok {
		r1 = rf(ctx, shardId, tableName, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DbGetFromShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbGetFromShard'
type MockClient_DbGetFromShard_Call struct {
	*mock.Call
}

// DbGetFromShard is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - tableName db.ShardedTableName
//   - key []byte
func (_e *MockClient_Expecter) DbGetFromShard(ctx interface{}, shardId interface{}, tableName interface{}, key interface{}) *MockClient_DbGetFromShard_Call {
	return &MockClient_DbGetFromShard_Call{Call: _e.mock.On("DbGetFromShard", ctx, shardId, tableName, key)}
}

func (_c *MockClient_DbGetFromShard_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, tableName db.ShardedTableName, key []byte)) *MockClient_DbGetFromShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(db.ShardedTableName), args[3].([]byte))
	})
	return _c
}

func (_c *MockClient_DbGetFromShard_Call) Return(_a0 []byte, _a1 error) *MockClient_DbGetFromShard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DbGetFromShard_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, db.ShardedTableName, []byte) ([]byte, error)) *MockClient_DbGetFromShard_Call {
	_c.Call.Return(run)
	return _c
}

// DbInitTimestamp provides a mock function with given fields: ctx, ts
func (_m *MockClient) DbInitTimestamp(ctx context.Context, ts uint64) error {
	ret := _m.Called(ctx, ts)

	if len(ret) == 0 {
		panic("no return value specified for DbInitTimestamp")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) error); ok {
		r0 = rf(ctx, ts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DbInitTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbInitTimestamp'
type MockClient_DbInitTimestamp_Call struct {
	*mock.Call
}

// DbInitTimestamp is a helper method to define mock.On call
//   - ctx context.Context
//   - ts uint64
func (_e *MockClient_Expecter) DbInitTimestamp(ctx interface{}, ts interface{}) *MockClient_DbInitTimestamp_Call {
	return &MockClient_DbInitTimestamp_Call{Call: _e.mock.On("DbInitTimestamp", ctx, ts)}
}

func (_c *MockClient_DbInitTimestamp_Call) Run(run func(ctx context.Context, ts uint64)) *MockClient_DbInitTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *MockClient_DbInitTimestamp_Call) Return(_a0 error) *MockClient_DbInitTimestamp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DbInitTimestamp_Call) RunAndReturn(run func(context.Context, uint64) error) *MockClient_DbInitTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// DeployContract provides a mock function with given fields: ctx, shardId, smartAccountAddress, payload, value, fee, pk
func (_m *MockClient) DeployContract(ctx context.Context, shardId internaltypes.ShardId, smartAccountAddress internaltypes.Address, payload internaltypes.DeployPayload, value internaltypes.Value, fee internaltypes.FeePack, pk *ecdsa.PrivateKey) (common.Hash, internaltypes.Address, error) {
	ret := _m.Called(ctx, shardId, smartAccountAddress, payload, value, fee, pk)

	if len(ret) == 0 {
		panic("no return value specified for DeployContract")
	}

	var r0 common.Hash
	var r1 internaltypes.Address
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.Address, internaltypes.DeployPayload, internaltypes.Value, internaltypes.FeePack, *ecdsa.PrivateKey) (common.Hash, internaltypes.Address, error)); ok {
		return rf(ctx, shardId, smartAccountAddress, payload, value, fee, pk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.Address, internaltypes.DeployPayload, internaltypes.Value, internaltypes.FeePack, *ecdsa.PrivateKey) common.Hash); ok {
		r0 = rf(ctx, shardId, smartAccountAddress, payload, value, fee, pk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, internaltypes.Address, internaltypes.DeployPayload, internaltypes.Value, internaltypes.FeePack, *ecdsa.PrivateKey) internaltypes.Address); ok {
		r1 = rf(ctx, shardId, smartAccountAddress, payload, value, fee, pk)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(internaltypes.Address)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, internaltypes.ShardId, internaltypes.Address, internaltypes.DeployPayload, internaltypes.Value, internaltypes.FeePack, *ecdsa.PrivateKey) error); ok {
		r2 = rf(ctx, shardId, smartAccountAddress, payload, value, fee, pk)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockClient_DeployContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeployContract'
type MockClient_DeployContract_Call struct {
	*mock.Call
}

// DeployContract is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - smartAccountAddress internaltypes.Address
//   - payload internaltypes.DeployPayload
//   - value internaltypes.Value
//   - fee internaltypes.FeePack
//   - pk *ecdsa.PrivateKey
func (_e *MockClient_Expecter) DeployContract(ctx interface{}, shardId interface{}, smartAccountAddress interface{}, payload interface{}, value interface{}, fee interface{}, pk interface{}) *MockClient_DeployContract_Call {
	return &MockClient_DeployContract_Call{Call: _e.mock.On("DeployContract", ctx, shardId, smartAccountAddress, payload, value, fee, pk)}
}

func (_c *MockClient_DeployContract_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, smartAccountAddress internaltypes.Address, payload internaltypes.DeployPayload, value internaltypes.Value, fee internaltypes.FeePack, pk *ecdsa.PrivateKey)) *MockClient_DeployContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(internaltypes.Address), args[3].(internaltypes.DeployPayload), args[4].(internaltypes.Value), args[5].(internaltypes.FeePack), args[6].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *MockClient_DeployContract_Call) Return(_a0 common.Hash, _a1 internaltypes.Address, _a2 error) *MockClient_DeployContract_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockClient_DeployContract_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, internaltypes.Address, internaltypes.DeployPayload, internaltypes.Value, internaltypes.FeePack, *ecdsa.PrivateKey) (common.Hash, internaltypes.Address, error)) *MockClient_DeployContract_Call {
	_c.Call.Return(run)
	return _c
}

// DeployExternal provides a mock function with given fields: ctx, shardId, deployPayload, fee
func (_m *MockClient) DeployExternal(ctx context.Context, shardId internaltypes.ShardId, deployPayload internaltypes.DeployPayload, fee internaltypes.FeePack) (common.Hash, internaltypes.Address, error) {
	ret := _m.Called(ctx, shardId, deployPayload, fee)

	if len(ret) == 0 {
		panic("no return value specified for DeployExternal")
	}

	var r0 common.Hash
	var r1 internaltypes.Address
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.DeployPayload, internaltypes.FeePack) (common.Hash, internaltypes.Address, error)); ok {
		return rf(ctx, shardId, deployPayload, fee)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.DeployPayload, internaltypes.FeePack) common.Hash); ok {
		r0 = rf(ctx, shardId, deployPayload, fee)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, internaltypes.DeployPayload, internaltypes.FeePack) internaltypes.Address); ok {
		r1 = rf(ctx, shardId, deployPayload, fee)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(internaltypes.Address)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, internaltypes.ShardId, internaltypes.DeployPayload, internaltypes.FeePack) error); ok {
		r2 = rf(ctx, shardId, deployPayload, fee)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockClient_DeployExternal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeployExternal'
type MockClient_DeployExternal_Call struct {
	*mock.Call
}

// DeployExternal is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - deployPayload internaltypes.DeployPayload
//   - fee internaltypes.FeePack
func (_e *MockClient_Expecter) DeployExternal(ctx interface{}, shardId interface{}, deployPayload interface{}, fee interface{}) *MockClient_DeployExternal_Call {
	return &MockClient_DeployExternal_Call{Call: _e.mock.On("DeployExternal", ctx, shardId, deployPayload, fee)}
}

func (_c *MockClient_DeployExternal_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, deployPayload internaltypes.DeployPayload, fee internaltypes.FeePack)) *MockClient_DeployExternal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(internaltypes.DeployPayload), args[3].(internaltypes.FeePack))
	})
	return _c
}

func (_c *MockClient_DeployExternal_Call) Return(_a0 common.Hash, _a1 internaltypes.Address, _a2 error) *MockClient_DeployExternal_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockClient_DeployExternal_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, internaltypes.DeployPayload, internaltypes.FeePack) (common.Hash, internaltypes.Address, error)) *MockClient_DeployExternal_Call {
	_c.Call.Return(run)
	return _c
}

// DoPanicOnShard provides a mock function with given fields: ctx, shardId
func (_m *MockClient) DoPanicOnShard(ctx context.Context, shardId internaltypes.ShardId) (uint64, error) {
	ret := _m.Called(ctx, shardId)

	if len(ret) == 0 {
		panic("no return value specified for DoPanicOnShard")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) (uint64, error)); ok {
		return rf(ctx, shardId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) uint64); ok {
		r0 = rf(ctx, shardId)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId) error); ok {
		r1 = rf(ctx, shardId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DoPanicOnShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoPanicOnShard'
type MockClient_DoPanicOnShard_Call struct {
	*mock.Call
}

// DoPanicOnShard is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
func (_e *MockClient_Expecter) DoPanicOnShard(ctx interface{}, shardId interface{}) *MockClient_DoPanicOnShard_Call {
	return &MockClient_DoPanicOnShard_Call{Call: _e.mock.On("DoPanicOnShard", ctx, shardId)}
}

func (_c *MockClient_DoPanicOnShard_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId)) *MockClient_DoPanicOnShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId))
	})
	return _c
}

func (_c *MockClient_DoPanicOnShard_Call) Return(_a0 uint64, _a1 error) *MockClient_DoPanicOnShard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DoPanicOnShard_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId) (uint64, error)) *MockClient_DoPanicOnShard_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateFee provides a mock function with given fields: ctx, args, blockId
func (_m *MockClient) EstimateFee(ctx context.Context, args *types.CallArgs, blockId interface{}) (*jsonrpc.EstimateFeeRes, error) {
	ret := _m.Called(ctx, args, blockId)

	if len(ret) == 0 {
		panic("no return value specified for EstimateFee")
	}

	var r0 *jsonrpc.EstimateFeeRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CallArgs, interface{}) (*jsonrpc.EstimateFeeRes, error)); ok {
		return rf(ctx, args, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CallArgs, interface{}) *jsonrpc.EstimateFeeRes); ok {
		r0 = rf(ctx, args, blockId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.EstimateFeeRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CallArgs, interface{}) error); ok {
		r1 = rf(ctx, args, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_EstimateFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateFee'
type MockClient_EstimateFee_Call struct {
	*mock.Call
}

// EstimateFee is a helper method to define mock.On call
//   - ctx context.Context
//   - args *types.CallArgs
//   - blockId interface{}
func (_e *MockClient_Expecter) EstimateFee(ctx interface{}, args interface{}, blockId interface{}) *MockClient_EstimateFee_Call {
	return &MockClient_EstimateFee_Call{Call: _e.mock.On("EstimateFee", ctx, args, blockId)}
}

func (_c *MockClient_EstimateFee_Call) Run(run func(ctx context.Context, args *types.CallArgs, blockId interface{})) *MockClient_EstimateFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.CallArgs), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_EstimateFee_Call) Return(_a0 *jsonrpc.EstimateFeeRes, _a1 error) *MockClient_EstimateFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_EstimateFee_Call) RunAndReturn(run func(context.Context, *types.CallArgs, interface{}) (*jsonrpc.EstimateFeeRes, error)) *MockClient_EstimateFee_Call {
	_c.Call.Return(run)
	return _c
}

// GasPrice provides a mock function with given fields: ctx, shardId
func (_m *MockClient) GasPrice(ctx context.Context, shardId internaltypes.ShardId) (internaltypes.Value, error) {
	ret := _m.Called(ctx, shardId)

	if len(ret) == 0 {
		panic("no return value specified for GasPrice")
	}

	var r0 internaltypes.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) (internaltypes.Value, error)); ok {
		return rf(ctx, shardId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) internaltypes.Value); ok {
		r0 = rf(ctx, shardId)
	} else {
		r0 = ret.Get(0).(internaltypes.Value)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId) error); ok {
		r1 = rf(ctx, shardId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GasPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GasPrice'
type MockClient_GasPrice_Call struct {
	*mock.Call
}

// GasPrice is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
func (_e *MockClient_Expecter) GasPrice(ctx interface{}, shardId interface{}) *MockClient_GasPrice_Call {
	return &MockClient_GasPrice_Call{Call: _e.mock.On("GasPrice", ctx, shardId)}
}

func (_c *MockClient_GasPrice_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId)) *MockClient_GasPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId))
	})
	return _c
}

func (_c *MockClient_GasPrice_Call) Return(_a0 internaltypes.Value, _a1 error) *MockClient_GasPrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GasPrice_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId) (internaltypes.Value, error)) *MockClient_GasPrice_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function with given fields: ctx, address, blockId
func (_m *MockClient) GetBalance(ctx context.Context, address internaltypes.Address, blockId interface{}) (internaltypes.Value, error) {
	ret := _m.Called(ctx, address, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 internaltypes.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) (internaltypes.Value, error)); ok {
		return rf(ctx, address, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) internaltypes.Value); ok {
		r0 = rf(ctx, address, blockId)
	} else {
		r0 = ret.Get(0).(internaltypes.Value)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, interface{}) error); ok {
		r1 = rf(ctx, address, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type MockClient_GetBalance_Call struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - address internaltypes.Address
//   - blockId interface{}
func (_e *MockClient_Expecter) GetBalance(ctx interface{}, address interface{}, blockId interface{}) *MockClient_GetBalance_Call {
	return &MockClient_GetBalance_Call{Call: _e.mock.On("GetBalance", ctx, address, blockId)}
}

func (_c *MockClient_GetBalance_Call) Run(run func(ctx context.Context, address internaltypes.Address, blockId interface{})) *MockClient_GetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetBalance_Call) Return(_a0 internaltypes.Value, _a1 error) *MockClient_GetBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetBalance_Call) RunAndReturn(run func(context.Context, internaltypes.Address, interface{}) (internaltypes.Value, error)) *MockClient_GetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlock provides a mock function with given fields: ctx, shardId, blockId, fullTx
func (_m *MockClient) GetBlock(ctx context.Context, shardId internaltypes.ShardId, blockId interface{}, fullTx bool) (*jsonrpc.RPCBlock, error) {
	ret := _m.Called(ctx, shardId, blockId, fullTx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlock")
	}

	var r0 *jsonrpc.RPCBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}, bool) (*jsonrpc.RPCBlock, error)); ok {
		return rf(ctx, shardId, blockId, fullTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}, bool) *jsonrpc.RPCBlock); ok {
		r0 = rf(ctx, shardId, blockId, fullTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.RPCBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, interface{}, bool) error); ok {
		r1 = rf(ctx, shardId, blockId, fullTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type MockClient_GetBlock_Call struct {
	*mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - blockId interface{}
//   - fullTx bool
func (_e *MockClient_Expecter) GetBlock(ctx interface{}, shardId interface{}, blockId interface{}, fullTx interface{}) *MockClient_GetBlock_Call {
	return &MockClient_GetBlock_Call{Call: _e.mock.On("GetBlock", ctx, shardId, blockId, fullTx)}
}

func (_c *MockClient_GetBlock_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, blockId interface{}, fullTx bool)) *MockClient_GetBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(interface{}), args[3].(bool))
	})
	return _c
}

func (_c *MockClient_GetBlock_Call) Return(_a0 *jsonrpc.RPCBlock, _a1 error) *MockClient_GetBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetBlock_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, interface{}, bool) (*jsonrpc.RPCBlock, error)) *MockClient_GetBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockTransactionCount provides a mock function with given fields: ctx, shardId, blockId
func (_m *MockClient) GetBlockTransactionCount(ctx context.Context, shardId internaltypes.ShardId, blockId interface{}) (uint64, error) {
	ret := _m.Called(ctx, shardId, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockTransactionCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}) (uint64, error)); ok {
		return rf(ctx, shardId, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}) uint64); ok {
		r0 = rf(ctx, shardId, blockId)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, interface{}) error); ok {
		r1 = rf(ctx, shardId, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetBlockTransactionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockTransactionCount'
type MockClient_GetBlockTransactionCount_Call struct {
	*mock.Call
}

// GetBlockTransactionCount is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - blockId interface{}
func (_e *MockClient_Expecter) GetBlockTransactionCount(ctx interface{}, shardId interface{}, blockId interface{}) *MockClient_GetBlockTransactionCount_Call {
	return &MockClient_GetBlockTransactionCount_Call{Call: _e.mock.On("GetBlockTransactionCount", ctx, shardId, blockId)}
}

func (_c *MockClient_GetBlockTransactionCount_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, blockId interface{})) *MockClient_GetBlockTransactionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetBlockTransactionCount_Call) Return(_a0 uint64, _a1 error) *MockClient_GetBlockTransactionCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetBlockTransactionCount_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, interface{}) (uint64, error)) *MockClient_GetBlockTransactionCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlocksRange provides a mock function with given fields: ctx, shardId, from, to, fullTx, batchSize
func (_m *MockClient) GetBlocksRange(ctx context.Context, shardId internaltypes.ShardId, from internaltypes.BlockNumber, to internaltypes.BlockNumber, fullTx bool, batchSize int) ([]*jsonrpc.RPCBlock, error) {
	ret := _m.Called(ctx, shardId, from, to, fullTx, batchSize)

	if len(ret) == 0 {
		panic("no return value specified for GetBlocksRange")
	}

	var r0 []*jsonrpc.RPCBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) ([]*jsonrpc.RPCBlock, error)); ok {
		return rf(ctx, shardId, from, to, fullTx, batchSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) []*jsonrpc.RPCBlock); ok {
		r0 = rf(ctx, shardId, from, to, fullTx, batchSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*jsonrpc.RPCBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) error); ok {
		r1 = rf(ctx, shardId, from, to, fullTx, batchSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetBlocksRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlocksRange'
type MockClient_GetBlocksRange_Call struct {
	*mock.Call
}

// GetBlocksRange is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - from internaltypes.BlockNumber
//   - to internaltypes.BlockNumber
//   - fullTx bool
//   - batchSize int
func (_e *MockClient_Expecter) GetBlocksRange(ctx interface{}, shardId interface{}, from interface{}, to interface{}, fullTx interface{}, batchSize interface{}) *MockClient_GetBlocksRange_Call {
	return &MockClient_GetBlocksRange_Call{Call: _e.mock.On("GetBlocksRange", ctx, shardId, from, to, fullTx, batchSize)}
}

func (_c *MockClient_GetBlocksRange_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, from internaltypes.BlockNumber, to internaltypes.BlockNumber, fullTx bool, batchSize int)) *MockClient_GetBlocksRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(internaltypes.BlockNumber), args[3].(internaltypes.BlockNumber), args[4].(bool), args[5].(int))
	})
	return _c
}

func (_c *MockClient_GetBlocksRange_Call) Return(_a0 []*jsonrpc.RPCBlock, _a1 error) *MockClient_GetBlocksRange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetBlocksRange_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) ([]*jsonrpc.RPCBlock, error)) *MockClient_GetBlocksRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetBootstrapConfig provides a mock function with given fields: ctx
func (_m *MockClient) GetBootstrapConfig(ctx context.Context) (*types.BootstrapConfig, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetBootstrapConfig")
	}

	var r0 *types.BootstrapConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.BootstrapConfig, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.BootstrapConfig); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BootstrapConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetBootstrapConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBootstrapConfig'
type MockClient_GetBootstrapConfig_Call struct {
	*mock.Call
}

// GetBootstrapConfig is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) GetBootstrapConfig(ctx interface{}) *MockClient_GetBootstrapConfig_Call {
	return &MockClient_GetBootstrapConfig_Call{Call: _e.mock.On("GetBootstrapConfig", ctx)}
}

func (_c *MockClient_GetBootstrapConfig_Call) Run(run func(ctx context.Context)) *MockClient_GetBootstrapConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_GetBootstrapConfig_Call) Return(_a0 *types.BootstrapConfig, _a1 error) *MockClient_GetBootstrapConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetBootstrapConfig_Call) RunAndReturn(run func(context.Context) (*types.BootstrapConfig, error)) *MockClient_GetBootstrapConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetCode provides a mock function with given fields: ctx, addr, blockId
func (_m *MockClient) GetCode(ctx context.Context, addr internaltypes.Address, blockId interface{}) (internaltypes.Code, error) {
	ret := _m.Called(ctx, addr, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetCode")
	}

	var r0 internaltypes.Code
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) (internaltypes.Code, error)); ok {
		return rf(ctx, addr, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) internaltypes.Code); ok {
		r0 = rf(ctx, addr, blockId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internaltypes.Code)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, interface{}) error); ok {
		r1 = rf(ctx, addr, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCode'
type MockClient_GetCode_Call struct {
	*mock.Call
}

// GetCode is a helper method to define mock.On call
//   - ctx context.Context
//   - addr internaltypes.Address
//   - blockId interface{}
func (_e *MockClient_Expecter) GetCode(ctx interface{}, addr interface{}, blockId interface{}) *MockClient_GetCode_Call {
	return &MockClient_GetCode_Call{Call: _e.mock.On("GetCode", ctx, addr, blockId)}
}

func (_c *MockClient_GetCode_Call) Run(run func(ctx context.Context, addr internaltypes.Address, blockId interface{})) *MockClient_GetCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetCode_Call) Return(_a0 internaltypes.Code, _a1 error) *MockClient_GetCode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetCode_Call) RunAndReturn(run func(context.Context, internaltypes.Address, interface{}) (internaltypes.Code, error)) *MockClient_GetCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetDebugBlock provides a mock function with given fields: ctx, shardId, blockId, fullTx
func (_m *MockClient) GetDebugBlock(ctx context.Context, shardId internaltypes.ShardId, blockId interface{}, fullTx bool) (*jsonrpc.DebugRPCBlock, error) {
	ret := _m.Called(ctx, shardId, blockId, fullTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDebugBlock")
	}

	var r0 *jsonrpc.DebugRPCBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}, bool) (*jsonrpc.DebugRPCBlock, error)); ok {
		return rf(ctx, shardId, blockId, fullTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, interface{}, bool) *jsonrpc.DebugRPCBlock); ok {
		r0 = rf(ctx, shardId, blockId, fullTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.DebugRPCBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, interface{}, bool) error); ok {
		r1 = rf(ctx, shardId, blockId, fullTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetDebugBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDebugBlock'
type MockClient_GetDebugBlock_Call struct {
	*mock.Call
}

// GetDebugBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - blockId interface{}
//   - fullTx bool
func (_e *MockClient_Expecter) GetDebugBlock(ctx interface{}, shardId interface{}, blockId interface{}, fullTx interface{}) *MockClient_GetDebugBlock_Call {
	return &MockClient_GetDebugBlock_Call{Call: _e.mock.On("GetDebugBlock", ctx, shardId, blockId, fullTx)}
}

func (_c *MockClient_GetDebugBlock_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, blockId interface{}, fullTx bool)) *MockClient_GetDebugBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(interface{}), args[3].(bool))
	})
	return _c
}

func (_c *MockClient_GetDebugBlock_Call) Return(_a0 *jsonrpc.DebugRPCBlock, _a1 error) *MockClient_GetDebugBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetDebugBlock_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, interface{}, bool) (*jsonrpc.DebugRPCBlock, error)) *MockClient_GetDebugBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetDebugBlocksRange provides a mock function with given fields: ctx, shardId, from, to, fullTx, batchSize
func (_m *MockClient) GetDebugBlocksRange(ctx context.Context, shardId internaltypes.ShardId, from internaltypes.BlockNumber, to internaltypes.BlockNumber, fullTx bool, batchSize int) ([]*jsonrpc.DebugRPCBlock, error) {
	ret := _m.Called(ctx, shardId, from, to, fullTx, batchSize)

	if len(ret) == 0 {
		panic("no return value specified for GetDebugBlocksRange")
	}

	var r0 []*jsonrpc.DebugRPCBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) ([]*jsonrpc.DebugRPCBlock, error)); ok {
		return rf(ctx, shardId, from, to, fullTx, batchSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) []*jsonrpc.DebugRPCBlock); ok {
		r0 = rf(ctx, shardId, from, to, fullTx, batchSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*jsonrpc.DebugRPCBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) error); ok {
		r1 = rf(ctx, shardId, from, to, fullTx, batchSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetDebugBlocksRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDebugBlocksRange'
type MockClient_GetDebugBlocksRange_Call struct {
	*mock.Call
}

// GetDebugBlocksRange is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
//   - from internaltypes.BlockNumber
//   - to internaltypes.BlockNumber
//   - fullTx bool
//   - batchSize int
func (_e *MockClient_Expecter) GetDebugBlocksRange(ctx interface{}, shardId interface{}, from interface{}, to interface{}, fullTx interface{}, batchSize interface{}) *MockClient_GetDebugBlocksRange_Call {
	return &MockClient_GetDebugBlocksRange_Call{Call: _e.mock.On("GetDebugBlocksRange", ctx, shardId, from, to, fullTx, batchSize)}
}

func (_c *MockClient_GetDebugBlocksRange_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId, from internaltypes.BlockNumber, to internaltypes.BlockNumber, fullTx bool, batchSize int)) *MockClient_GetDebugBlocksRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId), args[2].(internaltypes.BlockNumber), args[3].(internaltypes.BlockNumber), args[4].(bool), args[5].(int))
	})
	return _c
}

func (_c *MockClient_GetDebugBlocksRange_Call) Return(_a0 []*jsonrpc.DebugRPCBlock, _a1 error) *MockClient_GetDebugBlocksRange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetDebugBlocksRange_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId, internaltypes.BlockNumber, internaltypes.BlockNumber, bool, int) ([]*jsonrpc.DebugRPCBlock, error)) *MockClient_GetDebugBlocksRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetDebugContract provides a mock function with given fields: ctx, contractAddr, blockId
func (_m *MockClient) GetDebugContract(ctx context.Context, contractAddr internaltypes.Address, blockId interface{}) (*jsonrpc.DebugRPCContract, error) {
	ret := _m.Called(ctx, contractAddr, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetDebugContract")
	}

	var r0 *jsonrpc.DebugRPCContract
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) (*jsonrpc.DebugRPCContract, error)); ok {
		return rf(ctx, contractAddr, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) *jsonrpc.DebugRPCContract); ok {
		r0 = rf(ctx, contractAddr, blockId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.DebugRPCContract)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, interface{}) error); ok {
		r1 = rf(ctx, contractAddr, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetDebugContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDebugContract'
type MockClient_GetDebugContract_Call struct {
	*mock.Call
}

// GetDebugContract is a helper method to define mock.On call
//   - ctx context.Context
//   - contractAddr internaltypes.Address
//   - blockId interface{}
func (_e *MockClient_Expecter) GetDebugContract(ctx interface{}, contractAddr interface{}, blockId interface{}) *MockClient_GetDebugContract_Call {
	return &MockClient_GetDebugContract_Call{Call: _e.mock.On("GetDebugContract", ctx, contractAddr, blockId)}
}

func (_c *MockClient_GetDebugContract_Call) Run(run func(ctx context.Context, contractAddr internaltypes.Address, blockId interface{})) *MockClient_GetDebugContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetDebugContract_Call) Return(_a0 *jsonrpc.DebugRPCContract, _a1 error) *MockClient_GetDebugContract_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetDebugContract_Call) RunAndReturn(run func(context.Context, internaltypes.Address, interface{}) (*jsonrpc.DebugRPCContract, error)) *MockClient_GetDebugContract_Call {
	_c.Call.Return(run)
	return _c
}

// GetInTransactionByHash provides a mock function with given fields: ctx, hash
func (_m *MockClient) GetInTransactionByHash(ctx context.Context, hash common.Hash) (*jsonrpc.RPCInTransaction, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetInTransactionByHash")
	}

	var r0 *jsonrpc.RPCInTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) (*jsonrpc.RPCInTransaction, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *jsonrpc.RPCInTransaction); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.RPCInTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetInTransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInTransactionByHash'
type MockClient_GetInTransactionByHash_Call struct {
	*mock.Call
}

// GetInTransactionByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash common.Hash
func (_e *MockClient_Expecter) GetInTransactionByHash(ctx interface{}, hash interface{}) *MockClient_GetInTransactionByHash_Call {
	return &MockClient_GetInTransactionByHash_Call{Call: _e.mock.On("GetInTransactionByHash", ctx, hash)}
}

func (_c *MockClient_GetInTransactionByHash_Call) Run(run func(ctx context.Context, hash common.Hash)) *MockClient_GetInTransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash))
	})
	return _c
}

func (_c *MockClient_GetInTransactionByHash_Call) Return(_a0 *jsonrpc.RPCInTransaction, _a1 error) *MockClient_GetInTransactionByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetInTransactionByHash_Call) RunAndReturn(run func(context.Context, common.Hash) (*jsonrpc.RPCInTransaction, error)) *MockClient_GetInTransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetInTransactionReceipt provides a mock function with given fields: ctx, hash
func (_m *MockClient) GetInTransactionReceipt(ctx context.Context, hash common.Hash) (*jsonrpc.RPCReceipt, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetInTransactionReceipt")
	}

	var r0 *jsonrpc.RPCReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) (*jsonrpc.RPCReceipt, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *jsonrpc.RPCReceipt); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jsonrpc.RPCReceipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetInTransactionReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInTransactionReceipt'
type MockClient_GetInTransactionReceipt_Call struct {
	*mock.Call
}

// GetInTransactionReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - hash common.Hash
func (_e *MockClient_Expecter) GetInTransactionReceipt(ctx interface{}, hash interface{}) *MockClient_GetInTransactionReceipt_Call {
	return &MockClient_GetInTransactionReceipt_Call{Call: _e.mock.On("GetInTransactionReceipt", ctx, hash)}
}

func (_c *MockClient_GetInTransactionReceipt_Call) Run(run func(ctx context.Context, hash common.Hash)) *MockClient_GetInTransactionReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash))
	})
	return _c
}

func (_c *MockClient_GetInTransactionReceipt_Call) Return(_a0 *jsonrpc.RPCReceipt, _a1 error) *MockClient_GetInTransactionReceipt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetInTransactionReceipt_Call) RunAndReturn(run func(context.Context, common.Hash) (*jsonrpc.RPCReceipt, error)) *MockClient_GetInTransactionReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// GetNumShards provides a mock function with given fields: ctx
func (_m *MockClient) GetNumShards(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNumShards")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetNumShards_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNumShards'
type MockClient_GetNumShards_Call struct {
	*mock.Call
}

// GetNumShards is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) GetNumShards(ctx interface{}) *MockClient_GetNumShards_Call {
	return &MockClient_GetNumShards_Call{Call: _e.mock.On("GetNumShards", ctx)}
}

func (_c *MockClient_GetNumShards_Call) Run(run func(ctx context.Context)) *MockClient_GetNumShards_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_GetNumShards_Call) Return(_a0 uint64, _a1 error) *MockClient_GetNumShards_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetNumShards_Call) RunAndReturn(run func(context.Context) (uint64, error)) *MockClient_GetNumShards_Call {
	_c.Call.Return(run)
	return _c
}

// GetShardIdList provides a mock function with given fields: ctx
func (_m *MockClient) GetShardIdList(ctx context.Context) ([]internaltypes.ShardId, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetShardIdList")
	}

	var r0 []internaltypes.ShardId
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]internaltypes.ShardId, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []internaltypes.ShardId); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]internaltypes.ShardId)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetShardIdList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShardIdList'
type MockClient_GetShardIdList_Call struct {
	*mock.Call
}

// GetShardIdList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) GetShardIdList(ctx interface{}) *MockClient_GetShardIdList_Call {
	return &MockClient_GetShardIdList_Call{Call: _e.mock.On("GetShardIdList", ctx)}
}

func (_c *MockClient_GetShardIdList_Call) Run(run func(ctx context.Context)) *MockClient_GetShardIdList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockClient_GetShardIdList_Call) Return(_a0 []internaltypes.ShardId, _a1 error) *MockClient_GetShardIdList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetShardIdList_Call) RunAndReturn(run func(context.Context) ([]internaltypes.ShardId, error)) *MockClient_GetShardIdList_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokens provides a mock function with given fields: ctx, address, blockId
func (_m *MockClient) GetTokens(ctx context.Context, address internaltypes.Address, blockId interface{}) (map[internaltypes.TokenId]internaltypes.Value, error) {
	ret := _m.Called(ctx, address, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetTokens")
	}

	var r0 map[internaltypes.TokenId]internaltypes.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) (map[internaltypes.TokenId]internaltypes.Value, error)); ok {
		return rf(ctx, address, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) map[internaltypes.TokenId]internaltypes.Value); ok {
		r0 = rf(ctx, address, blockId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[internaltypes.TokenId]internaltypes.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, interface{}) error); ok {
		r1 = rf(ctx, address, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokens'
type MockClient_GetTokens_Call struct {
	*mock.Call
}

// GetTokens is a helper method to define mock.On call
//   - ctx context.Context
//   - address internaltypes.Address
//   - blockId interface{}
func (_e *MockClient_Expecter) GetTokens(ctx interface{}, address interface{}, blockId interface{}) *MockClient_GetTokens_Call {
	return &MockClient_GetTokens_Call{Call: _e.mock.On("GetTokens", ctx, address, blockId)}
}

func (_c *MockClient_GetTokens_Call) Run(run func(ctx context.Context, address internaltypes.Address, blockId interface{})) *MockClient_GetTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetTokens_Call) Return(_a0 map[internaltypes.TokenId]internaltypes.Value, _a1 error) *MockClient_GetTokens_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetTokens_Call) RunAndReturn(run func(context.Context, internaltypes.Address, interface{}) (map[internaltypes.TokenId]internaltypes.Value, error)) *MockClient_GetTokens_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionCount provides a mock function with given fields: ctx, address, blockId
func (_m *MockClient) GetTransactionCount(ctx context.Context, address internaltypes.Address, blockId interface{}) (internaltypes.Seqno, error) {
	ret := _m.Called(ctx, address, blockId)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionCount")
	}

	var r0 internaltypes.Seqno
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) (internaltypes.Seqno, error)); ok {
		return rf(ctx, address, blockId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, interface{}) internaltypes.Seqno); ok {
		r0 = rf(ctx, address, blockId)
	} else {
		r0 = ret.Get(0).(internaltypes.Seqno)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, interface{}) error); ok {
		r1 = rf(ctx, address, blockId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetTransactionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionCount'
type MockClient_GetTransactionCount_Call struct {
	*mock.Call
}

// GetTransactionCount is a helper method to define mock.On call
//   - ctx context.Context
//   - address internaltypes.Address
//   - blockId interface{}
func (_e *MockClient_Expecter) GetTransactionCount(ctx interface{}, address interface{}, blockId interface{}) *MockClient_GetTransactionCount_Call {
	return &MockClient_GetTransactionCount_Call{Call: _e.mock.On("GetTransactionCount", ctx, address, blockId)}
}

func (_c *MockClient_GetTransactionCount_Call) Run(run func(ctx context.Context, address internaltypes.Address, blockId interface{})) *MockClient_GetTransactionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(interface{}))
	})
	return _c
}

func (_c *MockClient_GetTransactionCount_Call) Return(_a0 internaltypes.Seqno, _a1 error) *MockClient_GetTransactionCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetTransactionCount_Call) RunAndReturn(run func(context.Context, internaltypes.Address, interface{}) (internaltypes.Seqno, error)) *MockClient_GetTransactionCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxpoolContent provides a mock function with given fields: ctx, shardId
func (_m *MockClient) GetTxpoolContent(ctx context.Context, shardId internaltypes.ShardId) (jsonrpc.TxPoolContent, error) {
	ret := _m.Called(ctx, shardId)

	if len(ret) == 0 {
		panic("no return value specified for GetTxpoolContent")
	}

	var r0 jsonrpc.TxPoolContent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) (jsonrpc.TxPoolContent, error)); ok {
		return rf(ctx, shardId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) jsonrpc.TxPoolContent); ok {
		r0 = rf(ctx, shardId)
	} else {
		r0 = ret.Get(0).(jsonrpc.TxPoolContent)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId) error); ok {
		r1 = rf(ctx, shardId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetTxpoolContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxpoolContent'
type MockClient_GetTxpoolContent_Call struct {
	*mock.Call
}

// GetTxpoolContent is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
func (_e *MockClient_Expecter) GetTxpoolContent(ctx interface{}, shardId interface{}) *MockClient_GetTxpoolContent_Call {
	return &MockClient_GetTxpoolContent_Call{Call: _e.mock.On("GetTxpoolContent", ctx, shardId)}
}

func (_c *MockClient_GetTxpoolContent_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId)) *MockClient_GetTxpoolContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId))
	})
	return _c
}

func (_c *MockClient_GetTxpoolContent_Call) Return(_a0 jsonrpc.TxPoolContent, _a1 error) *MockClient_GetTxpoolContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetTxpoolContent_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId) (jsonrpc.TxPoolContent, error)) *MockClient_GetTxpoolContent_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxpoolStatus provides a mock function with given fields: ctx, shardId
func (_m *MockClient) GetTxpoolStatus(ctx context.Context, shardId internaltypes.ShardId) (jsonrpc.TxPoolStatus, error) {
	ret := _m.Called(ctx, shardId)

	if len(ret) == 0 {
		panic("no return value specified for GetTxpoolStatus")
	}

	var r0 jsonrpc.TxPoolStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) (jsonrpc.TxPoolStatus, error)); ok {
		return rf(ctx, shardId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.ShardId) jsonrpc.TxPoolStatus); ok {
		r0 = rf(ctx, shardId)
	} else {
		r0 = ret.Get(0).(jsonrpc.TxPoolStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.ShardId) error); ok {
		r1 = rf(ctx, shardId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetTxpoolStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxpoolStatus'
type MockClient_GetTxpoolStatus_Call struct {
	*mock.Call
}

// GetTxpoolStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - shardId internaltypes.ShardId
func (_e *MockClient_Expecter) GetTxpoolStatus(ctx interface{}, shardId interface{}) *MockClient_GetTxpoolStatus_Call {
	return &MockClient_GetTxpoolStatus_Call{Call: _e.mock.On("GetTxpoolStatus", ctx, shardId)}
}

func (_c *MockClient_GetTxpoolStatus_Call) Run(run func(ctx context.Context, shardId internaltypes.ShardId)) *MockClient_GetTxpoolStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.ShardId))
	})
	return _c
}

func (_c *MockClient_GetTxpoolStatus_Call) Return(_a0 jsonrpc.TxPoolStatus, _a1 error) *MockClient_GetTxpoolStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetTxpoolStatus_Call) RunAndReturn(run func(context.Context, internaltypes.ShardId) (jsonrpc.TxPoolStatus, error)) *MockClient_GetTxpoolStatus_Call {
	_c.Call.Return(run)
	return _c
}

// PlainTextCall provides a mock function with given fields: ctx, requestBody
func (_m *MockClient) PlainTextCall(ctx context.Context, requestBody []byte) (json.RawMessage, error) {
	ret := _m.Called(ctx, requestBody)

	if len(ret) == 0 {
		panic("no return value specified for PlainTextCall")
	}

	var r0 json.RawMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) (json.RawMessage, error)); ok {
		return rf(ctx, requestBody)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte) json.RawMessage); ok {
		r0 = rf(ctx, requestBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, requestBody)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_PlainTextCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlainTextCall'
type MockClient_PlainTextCall_Call struct {
	*mock.Call
}

// PlainTextCall is a helper method to define mock.On call
//   - ctx context.Context
//   - requestBody []byte
func (_e *MockClient_Expecter) PlainTextCall(ctx interface{}, requestBody interface{}) *MockClient_PlainTextCall_Call {
	return &MockClient_PlainTextCall_Call{Call: _e.mock.On("PlainTextCall", ctx, requestBody)}
}

func (_c *MockClient_PlainTextCall_Call) Run(run func(ctx context.Context, requestBody []byte)) *MockClient_PlainTextCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte))
	})
	return _c
}

func (_c *MockClient_PlainTextCall_Call) Return(_a0 json.RawMessage, _a1 error) *MockClient_PlainTextCall_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_PlainTextCall_Call) RunAndReturn(run func(context.Context, []byte) (json.RawMessage, error)) *MockClient_PlainTextCall_Call {
	_c.Call.Return(run)
	return _c
}

// RawCall provides a mock function with given fields: ctx, method, params
func (_m *MockClient) RawCall(ctx context.Context, method string, params ...interface{}) (json.RawMessage, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, method)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RawCall")
	}

	var r0 json.RawMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (json.RawMessage, error)); ok {
		return rf(ctx, method, params...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) json.RawMessage); ok {
		r0 = rf(ctx, method, params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok {
		r1 = rf(ctx, method, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_RawCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RawCall'
type MockClient_RawCall_Call struct {
	*mock.Call
}

// RawCall is a helper method to define mock.On call
//   - ctx context.Context
//   - method string
//   - params ...interface{}
func (_e *MockClient_Expecter) RawCall(ctx interface{}, method interface{}, params ...interface{}) *MockClient_RawCall_Call {
	return &MockClient_RawCall_Call{Call: _e.mock.On("RawCall",
		append([]interface{}{ctx, method}, params...)...)}
}

func (_c *MockClient_RawCall_Call) Run(run func(ctx context.Context, method string, params ...interface{})) *MockClient_RawCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockClient_RawCall_Call) Return(_a0 json.RawMessage, _a1 error) *MockClient_RawCall_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_RawCall_Call) RunAndReturn(run func(context.Context, string, ...interface{}) (json.RawMessage, error)) *MockClient_RawCall_Call {
	_c.Call.Return(run)
	return _c
}

// SendExternalTransaction provides a mock function with given fields: ctx, calldata, contractAddress, pk, fee
func (_m *MockClient) SendExternalTransaction(ctx context.Context, calldata internaltypes.Code, contractAddress internaltypes.Address, pk *ecdsa.PrivateKey, fee internaltypes.FeePack) (common.Hash, error) {
	ret := _m.Called(ctx, calldata, contractAddress, pk, fee)

	if len(ret) == 0 {
		panic("no return value specified for SendExternalTransaction")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Code, internaltypes.Address, *ecdsa.PrivateKey, internaltypes.FeePack) (common.Hash, error)); ok {
		return rf(ctx, calldata, contractAddress, pk, fee)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Code, internaltypes.Address, *ecdsa.PrivateKey, internaltypes.FeePack) common.Hash); ok {
		r0 = rf(ctx, calldata, contractAddress, pk, fee)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Code, internaltypes.Address, *ecdsa.PrivateKey, internaltypes.FeePack) error); ok {
		r1 = rf(ctx, calldata, contractAddress, pk, fee)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SendExternalTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendExternalTransaction'
type MockClient_SendExternalTransaction_Call struct {
	*mock.Call
}

// SendExternalTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - calldata internaltypes.Code
//   - contractAddress internaltypes.Address
//   - pk *ecdsa.PrivateKey
//   - fee internaltypes.FeePack
func (_e *MockClient_Expecter) SendExternalTransaction(ctx interface{}, calldata interface{}, contractAddress interface{}, pk interface{}, fee interface{}) *MockClient_SendExternalTransaction_Call {
	return &MockClient_SendExternalTransaction_Call{Call: _e.mock.On("SendExternalTransaction", ctx, calldata, contractAddress, pk, fee)}
}

func (_c *MockClient_SendExternalTransaction_Call) Run(run func(ctx context.Context, calldata internaltypes.Code, contractAddress internaltypes.Address, pk *ecdsa.PrivateKey, fee internaltypes.FeePack)) *MockClient_SendExternalTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Code), args[2].(internaltypes.Address), args[3].(*ecdsa.PrivateKey), args[4].(internaltypes.FeePack))
	})
	return _c
}

func (_c *MockClient_SendExternalTransaction_Call) Return(_a0 common.Hash, _a1 error) *MockClient_SendExternalTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SendExternalTransaction_Call) RunAndReturn(run func(context.Context, internaltypes.Code, internaltypes.Address, *ecdsa.PrivateKey, internaltypes.FeePack) (common.Hash, error)) *MockClient_SendExternalTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SendRawTransaction provides a mock function with given fields: ctx, data
func (_m *MockClient) SendRawTransaction(ctx context.Context, data []byte) (common.Hash, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for SendRawTransaction")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) (common.Hash, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte) common.Hash); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SendRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendRawTransaction'
type MockClient_SendRawTransaction_Call struct {
	*mock.Call
}

// SendRawTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - data []byte
func (_e *MockClient_Expecter) SendRawTransaction(ctx interface{}, data interface{}) *MockClient_SendRawTransaction_Call {
	return &MockClient_SendRawTransaction_Call{Call: _e.mock.On("SendRawTransaction", ctx, data)}
}

func (_c *MockClient_SendRawTransaction_Call) Run(run func(ctx context.Context, data []byte)) *MockClient_SendRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte))
	})
	return _c
}

func (_c *MockClient_SendRawTransaction_Call) Return(_a0 common.Hash, _a1 error) *MockClient_SendRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SendRawTransaction_Call) RunAndReturn(run func(context.Context, []byte) (common.Hash, error)) *MockClient_SendRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SendTransaction provides a mock function with given fields: ctx, txn
func (_m *MockClient) SendTransaction(ctx context.Context, txn *internaltypes.ExternalTransaction) (common.Hash, error) {
	ret := _m.Called(ctx, txn)

	if len(ret) == 0 {
		panic("no return value specified for SendTransaction")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internaltypes.ExternalTransaction) (common.Hash, error)); ok {
		return rf(ctx, txn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internaltypes.ExternalTransaction) common.Hash); ok {
		r0 = rf(ctx, txn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internaltypes.ExternalTransaction) error); ok {
		r1 = rf(ctx, txn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SendTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendTransaction'
type MockClient_SendTransaction_Call struct {
	*mock.Call
}

// SendTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - txn *internaltypes.ExternalTransaction
func (_e *MockClient_Expecter) SendTransaction(ctx interface{}, txn interface{}) *MockClient_SendTransaction_Call {
	return &MockClient_SendTransaction_Call{Call: _e.mock.On("SendTransaction", ctx, txn)}
}

func (_c *MockClient_SendTransaction_Call) Run(run func(ctx context.Context, txn *internaltypes.ExternalTransaction)) *MockClient_SendTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*internaltypes.ExternalTransaction))
	})
	return _c
}

func (_c *MockClient_SendTransaction_Call) Return(_a0 common.Hash, _a1 error) *MockClient_SendTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SendTransaction_Call) RunAndReturn(run func(context.Context, *internaltypes.ExternalTransaction) (common.Hash, error)) *MockClient_SendTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SendTransactionViaSmartAccount provides a mock function with given fields: ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk
func (_m *MockClient) SendTransactionViaSmartAccount(ctx context.Context, smartAccountAddress internaltypes.Address, bytecode internaltypes.Code, fee internaltypes.FeePack, value internaltypes.Value, tokens []internaltypes.TokenBalance, contractAddress internaltypes.Address, pk *ecdsa.PrivateKey) (common.Hash, error) {
	ret := _m.Called(ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk)

	if len(ret) == 0 {
		panic("no return value specified for SendTransactionViaSmartAccount")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, internaltypes.Code, internaltypes.FeePack, internaltypes.Value, []internaltypes.TokenBalance, internaltypes.Address, *ecdsa.PrivateKey) (common.Hash, error)); ok {
		return rf(ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, internaltypes.Code, internaltypes.FeePack, internaltypes.Value, []internaltypes.TokenBalance, internaltypes.Address, *ecdsa.PrivateKey) common.Hash); ok {
		r0 = rf(ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, internaltypes.Code, internaltypes.FeePack, internaltypes.Value, []internaltypes.TokenBalance, internaltypes.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SendTransactionViaSmartAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendTransactionViaSmartAccount'
type MockClient_SendTransactionViaSmartAccount_Call struct {
	*mock.Call
}

// SendTransactionViaSmartAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - smartAccountAddress internaltypes.Address
//   - bytecode internaltypes.Code
//   - fee internaltypes.FeePack
//   - value internaltypes.Value
//   - tokens []internaltypes.TokenBalance
//   - contractAddress internaltypes.Address
//   - pk *ecdsa.PrivateKey
func (_e *MockClient_Expecter) SendTransactionViaSmartAccount(ctx interface{}, smartAccountAddress interface{}, bytecode interface{}, fee interface{}, value interface{}, tokens interface{}, contractAddress interface{}, pk interface{}) *MockClient_SendTransactionViaSmartAccount_Call {
	return &MockClient_SendTransactionViaSmartAccount_Call{Call: _e.mock.On("SendTransactionViaSmartAccount", ctx, smartAccountAddress, bytecode, fee, value, tokens, contractAddress, pk)}
}

func (_c *MockClient_SendTransactionViaSmartAccount_Call) Run(run func(ctx context.Context, smartAccountAddress internaltypes.Address, bytecode internaltypes.Code, fee internaltypes.FeePack, value internaltypes.Value, tokens []internaltypes.TokenBalance, contractAddress internaltypes.Address, pk *ecdsa.PrivateKey)) *MockClient_SendTransactionViaSmartAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(internaltypes.Code), args[3].(internaltypes.FeePack), args[4].(internaltypes.Value), args[5].([]internaltypes.TokenBalance), args[6].(internaltypes.Address), args[7].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *MockClient_SendTransactionViaSmartAccount_Call) Return(_a0 common.Hash, _a1 error) *MockClient_SendTransactionViaSmartAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SendTransactionViaSmartAccount_Call) RunAndReturn(run func(context.Context, internaltypes.Address, internaltypes.Code, internaltypes.FeePack, internaltypes.Value, []internaltypes.TokenBalance, internaltypes.Address, *ecdsa.PrivateKey) (common.Hash, error)) *MockClient_SendTransactionViaSmartAccount_Call {
	_c.Call.Return(run)
	return _c
}

// SetTokenName provides a mock function with given fields: ctx, contractAddr, name, pk
func (_m *MockClient) SetTokenName(ctx context.Context, contractAddr internaltypes.Address, name string, pk *ecdsa.PrivateKey) (common.Hash, error) {
	ret := _m.Called(ctx, contractAddr, name, pk)

	if len(ret) == 0 {
		panic("no return value specified for SetTokenName")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, string, *ecdsa.PrivateKey) (common.Hash, error)); ok {
		return rf(ctx, contractAddr, name, pk)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internaltypes.Address, string, *ecdsa.PrivateKey) common.Hash); ok {
		r0 = rf(ctx, contractAddr, name, pk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internaltypes.Address, string, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, contractAddr, name, pk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SetTokenName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTokenName'
type MockClient_SetTokenName_Call struct {
	*mock.Call
}

// SetTokenName is a helper method to define mock.On call
//   - ctx context.Context
//   - contractAddr internaltypes.Address
//   - name string
//   - pk *ecdsa.PrivateKey
func (_e *MockClient_Expecter) SetTokenName(ctx interface{}, contractAddr interface{}, name interface{}, pk interface{}) *MockClient_SetTokenName_Call {
	return &MockClient_SetTokenName_Call{Call: _e.mock.On("SetTokenName", ctx, contractAddr, name, pk)}
}

func (_c *MockClient_SetTokenName_Call) Run(run func(ctx context.Context, contractAddr internaltypes.Address, name string, pk *ecdsa.PrivateKey)) *MockClient_SetTokenName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internaltypes.Address), args[2].(string), args[3].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *MockClient_SetTokenName_Call) Return(_a0 common.Hash, _a1 error) *MockClient_SetTokenName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SetTokenName_Call) RunAndReturn(run func(context.Context, internaltypes.Address, string, *ecdsa.PrivateKey) (common.Hash, error)) *MockClient_SetTokenName_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
