# =nil; 101

This tutorial acts as a 'primer' for working with =nil;. It explains how to perform essential actions with the cluster: creating a new wallet, deploying a contract, and calling a method inside this contract.


## Set up the =nil; CLI

The =nil; CLI is an easy-to-use tool for interacting with the cluster. 

To install the CLI:

```bash
curl -fsSL https://github.com/NilFoundation/nil_cli/raw/master/install.sh | bash
```

To generate a new private key and set inside the CLI config:

```bash
nil keygen new
```

To point the CLI toward the RPC endpoint:

```bash
nil config set rpc_endpoint NIL_ENDPOINT
```

## Create a new wallet

In =nil; a wallet is just a smart contract that can handle payments. There are no other structural differences between a wallet and a smart contract, which means that wallets can support any logic that can be expressed inside a smart contract.

### Flow

To create a new wallet:

```bash
nil wallet new
```

Expected response:

```bash
Contract WALLET_ADDRESS balance is topped up by 100000000
Contract address: WALLET_ADDRESS
```

To check the wallet bytecode:

```bash
nil contract code WALLET_ADDRESS
```

To request a 'top up':

```bash
nil wallet top-up AMOUNT
```

To see the wallet address and its public key:

```bash
nil wallet info
```

### Advanced tutorials

* [**Creating a wallet**](essentials/creating-a-wallet.mdx)

## Deploy a smart contract

In =nil; contracts can be deployed on different execution shards that act as separate blockchains. Contracts can communicate with contracts on other shards, avoiding state fragmentation.

Any smart contract deployed in Ethereum-compatible networks and written in Solidity can be redeployed to =nil;

### Flow

Create a new contract containing this code:

```solidity showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Incrementer {
    uint256 private value;

    event ValueChanged(uint256 newValue);


    function increment() public {
        value += 1;
        emit ValueChanged(value);
    }

    function getValue() public view returns (uint256) {
        return value;
    }
}
```

Compile the contract:

```bash
solc -o ./Incrementer --bin --abi ./Incrementer.sol
```

Deploy a contract with the =nil; CLI:

```bash
nil wallet deploy ./Incrementer/Incrementer.bin
```

Expected output:

```bash
Contract address: INCREMENTER_ADDRESS
Transaction hash: TRANSACTION_HASH (shard 1)
```

Call the `increment()` function:

```bash
nil wallet send-message INCREMENTER_ADDRESS increment --abi ./Incrementer/Incrementer.abi
```

Retrieve the result:

```bash
nil contract call-readonly INCREMENTER_ADDRESS getValue --abi ./Incrementer/Incrementer.abi
```

### Advanced tutorials

* [**Reading and writing to =nil;**](essentials/reading-writing-info.mdx)
* [**Writing a smart contract**](working-with-smart-contracts/writing-a-contract.mdx)
* [**Deploying a contract**](working-with-smart-contracts/deploying-a-contract.mdx)

## Make a cross-shard call

When a smart contract makes a call to another smart contract deployed on a separate shard, the destination shard retrieves the resulting message and processes it. To make thing simpler, the `Nil.sol` library provides the `async_call()` function: it calls a special precompiled contract that allows for easily passing messages between shards.

## Flow

Create a new contract with the following code:

```solidity showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "./Nil.sol";

contract Caller {
    using Nil for address;

    receive() external payable {}

    function call(address dst) public payable {
        Nil.asyncCall(
            dst,
            msg.sender,
            msg.sender,
            100000,
            2,
            false,
            0,
            abi.encodeWithSignature("increment()")
        );
    }

    function verifyExternal(
        uint256,
        bytes calldata
    ) external pure returns (bool) {
        return true;
    }
}
```

Compile it and deploy it to Shard 2:

```bash
solc -o ./Caller --bin --abi ./Caller.sol 
nil wallet deploy ./Caller/Caller.bin --shard-id 2
```

Expected output:

```bash
Contract address: CALLER_ADDRESS
Transaction hash: TRANSACTION_HASH (shard 1)
```

Note that `CALLER_ADDRESS` starts with `0x0002`, which indicates that `Caller` is indeed deployed on Shard 2.

Send tokens to `Caller` and call the `call()` function:

```
nil wallet send-tokens CALLER_ADDRESS 3000000
nil wallet send-message CALLER_ADDRESS call INCREMENTER_ADDRESS --abi ./Caller/Caller.abi
```

Retrieve the result:

```bash
nil contract call-readonly INCREMENTER_ADDRESS getValue --abi ./Incrementer/Incrementer.abi
```

### Advanced tutorials

* [**Handling async execution**](essentials/handling-async-execution.mdx)
* [**Calling methods inside a contract**](working-with-smart-contracts/calling-contract-methods.mdx)

## Tokens and multi-currency

=nil; has base tokens that are used to pay for essential functionalities such as deploying contracts.

However, each contract can also create a custom currency. A contract can only be the owner of one custom currency. While custom currencies can be transferred between contracts, they cannot be used to pay for operations inside =nil;. 

:::info

Non-owners cannot perform any operations with a custom currency.

:::

### Flow

Create a new wallet:

```bash
nil wallet new --salt 2
```

Create a new currency and withdraw it:

```bash
nil minter create-currency NEW_WALLET_ADDRESS 50000 new-currency --withdraw
```

Check the currencies of the wallet:

```bash
nil contract currencies NEW_WALLET_ADDRESS
```

Expected output:

```bash
Contract currencies:
Balance: 50000 CurrencyId=CURRENCY_ID
```

### Advanced tutorials

* [**Tokens and multi-currency support**](essentials/tokens-multi-currency.mdx)
