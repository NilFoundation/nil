package rpctest

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/crypto"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
)

func (suite *SuiteRpc) getFaucetAddress() types.Address {
	suite.T().Helper()

	faucetCode, err := contracts.GetCode("Faucet")
	suite.Require().NoError(err)

	return types.CreateAddress(types.BaseShardId, faucetCode)
}

func (suite *SuiteRpc) getWalletConstructorCode(ownerPublicKey []byte) []byte {
	suite.T().Helper()

	walletCode, err := contracts.GetCode("Wallet")
	suite.Require().NoError(err)
	walletAbi, err := contracts.GetAbi("Wallet")
	suite.Require().NoError(err)
	args, err := walletAbi.Pack("", ownerPublicKey)
	suite.Require().NoError(err)
	return append(walletCode, args...)
}

func (suite *SuiteRpc) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	faucetABI, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)

	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := types.NewUint256(123)
	calldata, err := faucetABI.Pack("createWallet", ownerPublicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	faucetAddress := suite.getFaucetAddress()
	seqno := suite.getTransactionCount(faucetAddress, "latest")
	msgExternal := &types.Message{
		Seqno:    seqno,
		From:     faucetAddress, // Now From should point to the address of an existing contract
		To:       faucetAddress,
		Value:    *types.NewUint256(0),
		GasLimit: *types.NewUint256(200000),
		Data:     calldata,
		Deploy:   false,
	}
	suite.Require().NoError(msgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Faucet does not check

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)
	suite.Equal(msgExternal.Hash(), resHash)

	suite.waitForReceiptOnShard(types.BaseShardId, msgExternal)

	walletCode := suite.getWalletConstructorCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(faucetAddress, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, msgExternal)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (suite *SuiteRpc) deployContractViaFaucet(code []byte, ownerPrivateKey *ecdsa.PrivateKey, value types.Uint256) types.Address {
	faucetAddress := suite.getFaucetAddress()
	seqno := suite.getTransactionCount(faucetAddress, "latest")

	walletAddress := types.CreateAddress(faucetAddress.ShardId(), code)

	sendMsgInternal := &types.Message{
		Seqno:    seqno,
		From:     faucetAddress,
		To:       walletAddress,
		Value:    value,
		GasLimit: *types.NewUint256(100000),
		GasPrice: *types.NewUint256(1),
		Internal: true,
		Deploy:   false,
	}
	sendMsgInternalData, err := sendMsgInternal.MarshalSSZ()
	suite.Require().NoError(err)

	// Make external message to the Main Wallet
	faucetAbi, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)
	calldata, err := faucetAbi.Pack("send", sendMsgInternalData)
	suite.Require().NoError(err)

	sendMsgExternal := &types.Message{
		Seqno:    seqno,
		From:     faucetAddress,
		To:       faucetAddress,
		Value:    *types.NewUint256(0),
		GasLimit: *types.NewUint256(20000000),
		Data:     calldata,
	}
	suite.Require().NoError(sendMsgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Fauсet does not check

	result, err := suite.client.SendMessage(sendMsgExternal)
	suite.Require().NoError(err)
	suite.Equal(sendMsgExternal.Hash(), result)

	res := suite.waitForReceiptOnShard(walletAddress.ShardId(), sendMsgExternal)
	suite.Require().Equal(faucetAddress, res.ContractAddress)

	deployPayload := types.BuildDeployPayload(code, common.EmptyHash)

	deployMsgExternal := &types.Message{
		Seqno:    seqno,
		From:     walletAddress,
		To:       walletAddress,
		Value:    *types.NewUint256(0),
		GasLimit: *types.NewUint256(100000),
		GasPrice: *types.NewUint256(1),
		Data:     deployPayload.Bytes(),
		Internal: false,
		Deploy:   true,
	}
	suite.Require().NoError(deployMsgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Fauсet does not check

	result, err = suite.client.SendMessage(deployMsgExternal)
	suite.Require().NoError(err)
	suite.Equal(deployMsgExternal.Hash(), result)

	res = suite.waitForReceiptOnShard(walletAddress.ShardId(), deployMsgExternal)
	suite.Require().Equal(walletAddress, res.ContractAddress)

	return walletAddress
}

func (suite *SuiteRpc) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)

	var value int64 = 100000
	walletAddress := suite.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}

func (suite *SuiteRpc) TestDeployContractViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 1000000
	walletCode := suite.getWalletConstructorCode(userPublicKey)
	walletAddr := suite.deployContractViaFaucet(walletCode, userPrivateKey, *types.NewUint256(value))

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddr, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
}
