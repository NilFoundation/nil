package rpctest

import (
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/crypto"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
)

func (suite *SuiteRpc) createWalletViaFaucet(value int64) types.Address {
	privateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	publicKey := crypto.CompressPubkey(&privateKey.PublicKey)

	faucetABI, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)

	salt := types.NewUint256(123)
	calldata, err := faucetABI.Pack("createWallet", publicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	faucetCode, err := contracts.GetCode("Faucet")
	suite.Require().NoError(err)

	faucetAddr := types.CreateAddress(types.BaseShardId, faucetCode)

	seqno := suite.getTransactionCount(faucetAddr, "latest")
	msgExternal := &types.Message{
		Seqno:    seqno,
		From:     faucetAddr, // Now From should point to the address of an existing contract
		To:       faucetAddr,
		Value:    *types.NewUint256(0),
		GasLimit: *types.NewUint256(200000),
		Data:     calldata,
		Deploy:   false,
	}
	suite.Require().NoError(msgExternal.Sign(privateKey)) // We sign the message with our key, Faucet does not check

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)
	suite.Equal(msgExternal.Hash(), resHash)

	suite.waitForReceiptOnShard(types.BaseShardId, msgExternal)

	walletCode, err := contracts.GetCode("Wallet")
	suite.Require().NoError(err)
	walletAbi, err := contracts.GetAbi("Wallet")
	suite.Require().NoError(err)
	args, err := walletAbi.Pack("", publicKey)
	suite.Require().NoError(err)
	walletCode = append(walletCode, args...)
	addrWallet := types.CreateAddressForCreate2(faucetAddr, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, msgExternal)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(addrWallet.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return addrWallet
}

func (suite *SuiteRpc) TestFaucet() {
	var value int64 = 100000
	walletAddr := suite.createWalletViaFaucet(value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddr, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}
