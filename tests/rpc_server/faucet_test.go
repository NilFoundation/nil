package rpctest

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rs/zerolog/log"
)

func (suite *SuiteRpc) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := types.NewUint256(123)
	callData, err := contracts.NewCallData(contracts.NameFaucet, "createWallet", ownerPublicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	seqno, err := suite.client.GetTransactionCount(types.FaucetAddress, "latest")
	suite.Require().NoError(err)

	msgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    types.FaucetAddress,
		Data:  callData,
		Kind:  types.ExecutionMessageKind,
	}

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)

	suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	walletCode := contracts.PrepareDefaultWalletForOwnerCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(types.FaucetAddress, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (suite *SuiteRpc) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)

	var value int64 = 100000
	walletAddress := suite.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}

func (suite *SuiteRpc) TestDeployContractViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 123_456_789
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(userPublicKey)

	code := types.BuildDeployPayload(walletCode, common.EmptyHash)
	walletAddr := types.CreateAddress(types.FaucetAddress.ShardId(), code)
	msgHash, err := suite.client.TopUpViaFaucet(walletAddr, types.NewUint256(value))
	suite.Require().NoError(err)
	receipt := suite.waitForReceiptOnShard(walletAddr.ShardId(), msgHash)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	msgHash, receiptContractAddress, err := suite.client.DeployExternal(walletAddr.ShardId(), code)
	suite.Require().NoError(err)
	suite.Require().Equal(walletAddr, receiptContractAddress)
	receipt = suite.waitForReceiptOnShard(walletAddr.ShardId(), msgHash)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err := suite.client.GetBalance(walletAddr, "latest")
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
	log.Logger.Info().Msgf("Spent %v nil", value-balance.Uint64())
}

func (suite *SuiteRpc) TestTopUpViaFaucet() {
	pk, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	pubKey := crypto.CompressPubkey(&pk.PublicKey)
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(pubKey)

	address, receipt := suite.deployContractViaMainWallet(types.BaseShardId, types.BuildDeployPayload(walletCode, common.EmptyHash), types.NewUint256(0))
	receipt = suite.waitForReceiptOnShard(types.MainWalletAddress.ShardId(), receipt.MsgHash)
	suite.Require().NotNil(receipt)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	testTopUp := func(initialValue uint64, value uint64, expectedValue uint64, delta float64) {
		balance, err := suite.client.GetBalance(address, transport.LatestBlockNumber)
		suite.Require().NoError(err)
		suite.Require().Equal(initialValue, balance.Uint64())

		code, err := suite.client.GetCode(address, transport.LatestBlockNumber)
		suite.Require().NoError(err)
		suite.Require().NotEmpty(code)

		mshHash, err := suite.client.TopUpViaFaucet(address, types.NewUint256(value))
		suite.Require().NoError(err)
		receipt = suite.waitForReceiptOnShard(address.ShardId(), mshHash)
		suite.Require().NotNil(receipt)
		suite.Require().True(receipt.Success)
		for _, r := range receipt.OutReceipts {
			suite.Require().True(r.Success)
		}

		balance, err = suite.client.GetBalance(address, transport.LatestBlockNumber)
		suite.Require().NoError(err)
		suite.Require().InDelta(expectedValue, balance.Uint64(), delta)
	}

	var value1 uint64 = 5 * 1_000_000_000_000_000
	balance1 := value1
	suite.Run("Top up for the first time without exceeding the limit", func() {
		testTopUp(0, value1, balance1, 0)
	})

	var value2 uint64 = 4 * 1_000_000_000_000_000
	balance2 := balance1 + value2
	suite.Run("Top up for the second time without exceeding the limit", func() {
		testTopUp(balance1, value2, balance2, 0)
	})

	var value3 uint64 = 5 * 1_000_000_000_000_000
	var balance3 uint64 = 10_000_000_000_000_000
	suite.Run("Top up over limit", func() {
		testTopUp(balance2, value3, balance3, float64(balance3)*0.01)
	})
}
