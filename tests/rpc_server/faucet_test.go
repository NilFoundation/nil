package rpctest

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rs/zerolog/log"
)

func (suite *SuiteRpc) getWalletConstructorCode(ownerPublicKey []byte) []byte {
	suite.T().Helper()

	walletCode, err := contracts.GetCode("Wallet")
	suite.Require().NoError(err)
	walletAbi, err := contracts.GetAbi("Wallet")
	suite.Require().NoError(err)
	args, err := walletAbi.Pack("", ownerPublicKey)
	suite.Require().NoError(err)
	return append(walletCode, args...)
}

func (suite *SuiteRpc) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	faucetABI, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)

	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := types.NewUint256(123)
	calldata, err := faucetABI.Pack("createWallet", ownerPublicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	seqno, err := suite.client.GetTransactionCount(types.FaucetAddress, "latest")
	suite.Require().NoError(err)

	msgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    types.FaucetAddress,
		Data:  calldata,
		Kind:  types.ExecutionMessageKind,
	}

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)

	suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	walletCode := suite.getWalletConstructorCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(types.FaucetAddress, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (suite *SuiteRpc) withdrawFromFaucet(code []byte, ownerPrivateKey *ecdsa.PrivateKey, value types.Uint256) types.Address {
	seqno, err := suite.client.GetTransactionCount(types.FaucetAddress, "latest")
	suite.Require().NoError(err)

	codeTmp := types.BuildDeployPayload(code, common.EmptyHash)
	walletAddress := types.CreateAddress(types.FaucetAddress.ShardId(), codeTmp)

	// Make external message to the Faucet
	faucetAbi, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)
	calldata, err := faucetAbi.Pack("withdrawTo", walletAddress, big.NewInt(0).SetBytes(value.Bytes()))
	suite.Require().NoError(err)

	sendMsgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    types.FaucetAddress,
		Data:  calldata,
	}
	suite.Require().NoError(sendMsgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Fau—Ået does not check

	result, err := suite.client.SendMessage(sendMsgExternal)
	suite.Require().NoError(err)

	res := suite.waitForReceiptOnShard(walletAddress.ShardId(), result)
	suite.Require().Equal(types.FaucetAddress, res.ContractAddress)

	return walletAddress
}

func (suite *SuiteRpc) deployContract(address types.Address, code []byte, ownerPrivateKey *ecdsa.PrivateKey) types.Address {
	seqno, err := suite.client.GetTransactionCount(address, "latest")
	suite.Require().NoError(err)

	deployPayload := types.BuildDeployPayload(code, common.EmptyHash)
	deployMsgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    address,
		Data:  deployPayload.Bytes(),
		Kind:  types.DeployMessageKind,
	}
	suite.Require().NoError(deployMsgExternal.Sign(ownerPrivateKey))

	result, err := suite.client.SendMessage(deployMsgExternal)
	suite.Require().NoError(err)

	res := suite.waitForReceiptOnShard(address.ShardId(), result)
	suite.Require().True(res.Success)
	return res.ContractAddress
}

func (suite *SuiteRpc) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)

	var value int64 = 100000
	walletAddress := suite.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}

func (suite *SuiteRpc) testDeployContractViaFaucet(withdraw bool) {
	suite.T().Helper()
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 123_456_789
	walletCode := suite.getWalletConstructorCode(userPublicKey)
	var walletAddr types.Address
	if withdraw {
		walletAddr = suite.withdrawFromFaucet(walletCode, userPrivateKey, *types.NewUint256(value))
	} else {
		code := types.BuildDeployPayload(walletCode, common.EmptyHash)
		walletAddr = types.CreateAddress(types.FaucetAddress.ShardId(), code)
		mshHash, err := suite.client.TopUpViaFaucet(walletAddr, types.NewUint256(value))
		suite.Require().NoError(err)
		receipt := suite.waitForReceiptOnShard(walletAddr.ShardId(), mshHash)
		suite.Require().True(receipt.Success)
	}
	receiptContractAddress := suite.deployContract(walletAddr, walletCode, userPrivateKey)
	suite.Require().Equal(walletAddr, receiptContractAddress)

	balance, err := suite.client.GetBalance(walletAddr, "latest")
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
	log.Logger.Info().Msgf("Spent %v nil", value-balance.Uint64())
}

func (suite *SuiteRpc) TestDeployContractViaFaucetWithSend() {
	suite.testDeployContractViaFaucet(false)
}

func (suite *SuiteRpc) TestDeployContractViaFaucetWithWithdraw() {
	suite.testDeployContractViaFaucet(true)
}

func (suite *SuiteRpc) TestTopUpViaFaucet() {
	pk, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	pubKey := crypto.CompressPubkey(&pk.PublicKey)
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(pubKey)

	address, receipt := suite.deployContractViaMainWallet(types.BaseShardId, walletCode, types.NewUint256(defaultContractValue))
	receipt = suite.waitForReceiptOnShard(types.MainWalletAddress.ShardId(), receipt.MsgHash)
	suite.Require().NotNil(receipt)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err := suite.client.GetBalance(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().Equal(defaultContractValue, balance.Uint64())

	code, err := suite.client.GetCode(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().NotEmpty(code)

	const value = 100500
	mshHash, err := suite.client.TopUpViaFaucet(address, types.NewUint256(value))
	suite.Require().NoError(err)
	receipt = suite.waitForReceiptOnShard(address.ShardId(), mshHash)
	suite.Require().NotNil(receipt)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err = suite.client.GetBalance(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().Equal(defaultContractValue+value, balance.Uint64())
}
