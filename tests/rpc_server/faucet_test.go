package rpctest

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rs/zerolog/log"
)

func (suite *SuiteRpc) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	faucetABI, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)

	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := types.NewUint256(123)
	calldata, err := faucetABI.Pack("createWallet", ownerPublicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	seqno, err := suite.client.GetTransactionCount(types.FaucetAddress, "latest")
	suite.Require().NoError(err)

	msgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    types.FaucetAddress,
		Data:  calldata,
		Kind:  types.ExecutionMessageKind,
	}

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)

	suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	walletCode := contracts.PrepareDefaultWalletForOwnerCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(types.FaucetAddress, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (suite *SuiteRpc) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)

	var value int64 = 100000
	walletAddress := suite.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}

func (suite *SuiteRpc) TestDeployContractViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 123_456_789
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(userPublicKey)

	code := types.BuildDeployPayload(walletCode, common.EmptyHash)
	walletAddr := types.CreateAddress(types.FaucetAddress.ShardId(), code)
	msgHash, err := suite.client.TopUpViaFaucet(walletAddr, types.NewUint256(value))
	suite.Require().NoError(err)
	receipt := suite.waitForReceiptOnShard(walletAddr.ShardId(), msgHash)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	msgHash, receiptContractAddress, err := suite.client.DeployExternal(walletAddr.ShardId(), code)
	suite.Require().NoError(err)
	suite.Require().Equal(walletAddr, receiptContractAddress)
	receipt = suite.waitForReceiptOnShard(walletAddr.ShardId(), msgHash)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err := suite.client.GetBalance(walletAddr, "latest")
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
	log.Logger.Info().Msgf("Spent %v nil", value-balance.Uint64())
}

func (suite *SuiteRpc) TestTopUpViaFaucet() {
	pk, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	pubKey := crypto.CompressPubkey(&pk.PublicKey)
	walletCode := contracts.PrepareDefaultWalletForOwnerCode(pubKey)

	address, receipt := suite.deployContractViaMainWallet(types.BaseShardId, types.BuildDeployPayload(walletCode, common.EmptyHash), types.NewUint256(defaultContractValue))
	receipt = suite.waitForReceiptOnShard(types.MainWalletAddress.ShardId(), receipt.MsgHash)
	suite.Require().NotNil(receipt)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err := suite.client.GetBalance(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().Equal(defaultContractValue, balance.Uint64())

	code, err := suite.client.GetCode(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().NotEmpty(code)

	const value = 100500
	mshHash, err := suite.client.TopUpViaFaucet(address, types.NewUint256(value))
	suite.Require().NoError(err)
	receipt = suite.waitForReceiptOnShard(address.ShardId(), mshHash)
	suite.Require().NotNil(receipt)
	suite.Require().True(receipt.Success)
	for _, r := range receipt.OutReceipts {
		suite.Require().True(r.Success)
	}

	balance, err = suite.client.GetBalance(address, transport.LatestBlockNumber)
	suite.Require().NoError(err)
	suite.Require().Equal(defaultContractValue+value, balance.Uint64())
}
