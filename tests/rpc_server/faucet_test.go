package rpctest

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/NilFoundation/nil/common"
	"github.com/NilFoundation/nil/contracts"
	"github.com/NilFoundation/nil/core/crypto"
	"github.com/NilFoundation/nil/core/execution"
	"github.com/NilFoundation/nil/core/types"
	"github.com/NilFoundation/nil/rpc/transport"
)

func (suite *SuiteRpc) getFaucetAddress() types.Address {
	suite.T().Helper()

	zeroStateConfig, err := execution.ParseZeroStateConfig(execution.DefaultZeroStateConfig)
	suite.Require().NoError(err)
	faucetAddress := zeroStateConfig.GetContractAddress("Faucet")
	suite.Require().NotNil(faucetAddress)
	return *faucetAddress
}

func (suite *SuiteRpc) getWalletConstructorCode(ownerPublicKey []byte) []byte {
	suite.T().Helper()

	walletCode, err := contracts.GetCode("Wallet")
	suite.Require().NoError(err)
	walletAbi, err := contracts.GetAbi("Wallet")
	suite.Require().NoError(err)
	args, err := walletAbi.Pack("", ownerPublicKey)
	suite.Require().NoError(err)
	return append(walletCode, args...)
}

func (suite *SuiteRpc) createWalletViaFaucet(ownerPrivateKey *ecdsa.PrivateKey, value int64) types.Address {
	faucetABI, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)

	ownerPublicKey := crypto.CompressPubkey(&ownerPrivateKey.PublicKey)

	salt := types.NewUint256(123)
	calldata, err := faucetABI.Pack("createWallet", ownerPublicKey, salt.Bytes32(), big.NewInt(value))
	suite.Require().NoError(err)

	faucetAddress := suite.getFaucetAddress()
	seqno, err := suite.client.GetTransactionCount(faucetAddress, "latest")
	suite.Require().NoError(err)

	msgExternal := &types.ExternalMessage{
		Seqno:  seqno,
		To:     faucetAddress,
		Data:   calldata,
		Deploy: false,
	}

	resHash, err := suite.client.SendMessage(msgExternal)
	suite.Require().NoError(err)

	suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	walletCode := suite.getWalletConstructorCode(ownerPublicKey)
	walletAddr := types.CreateAddressForCreate2(faucetAddress, walletCode, salt.Bytes32())

	res := suite.waitForReceiptOnShard(types.BaseShardId, resHash)

	// Checking whether the address generated by CREATE2 matches the expected one
	suite.Require().Equal(common.LeftPadBytes(walletAddr.Bytes(), 32), []byte(res.Logs[0].Data[:]))
	return walletAddr
}

func (suite *SuiteRpc) sendViaFaucet(code []byte, ownerPrivateKey *ecdsa.PrivateKey, value types.Uint256) types.Address {
	faucetAddress := suite.getFaucetAddress()
	seqno, err := suite.client.GetTransactionCount(faucetAddress, "latest")
	suite.Require().NoError(err)

	walletAddress := types.CreateAddress(faucetAddress.ShardId(), code)

	sendMsgInternal := &types.Message{
		Seqno:    seqno,
		From:     faucetAddress,
		To:       walletAddress,
		Value:    value,
		GasLimit: *types.NewUint256(100000),
		GasPrice: *types.NewUint256(1),
		Internal: true,
		Deploy:   false,
	}
	sendMsgInternalData, err := sendMsgInternal.MarshalSSZ()
	suite.Require().NoError(err)

	// Make external message to the Faucet
	faucetAbi, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)
	calldata, err := faucetAbi.Pack("send", sendMsgInternalData)
	suite.Require().NoError(err)

	sendMsgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    faucetAddress,
		Data:  calldata,
	}
	suite.Require().NoError(sendMsgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Fauсet does not check

	result, err := suite.client.SendMessage(sendMsgExternal)
	suite.Require().NoError(err)

	res := suite.waitForReceiptOnShard(walletAddress.ShardId(), result)
	suite.Require().Equal(faucetAddress, res.ContractAddress)

	return walletAddress
}

func (suite *SuiteRpc) withdrawFromFaucet(code []byte, ownerPrivateKey *ecdsa.PrivateKey, value types.Uint256) types.Address {
	faucetAddress := suite.getFaucetAddress()
	seqno, err := suite.client.GetTransactionCount(faucetAddress, "latest")
	suite.Require().NoError(err)

	walletAddress := types.CreateAddress(faucetAddress.ShardId(), code)

	// Make external message to the Faucet
	faucetAbi, err := contracts.GetAbi("Faucet")
	suite.Require().NoError(err)
	calldata, err := faucetAbi.Pack("withdrawTo", walletAddress, big.NewInt(0).SetBytes(value.Bytes()))
	suite.Require().NoError(err)

	sendMsgExternal := &types.ExternalMessage{
		Seqno: seqno,
		To:    faucetAddress,
		Data:  calldata,
	}
	suite.Require().NoError(sendMsgExternal.Sign(ownerPrivateKey)) // We sign the message with our key, Fauсet does not check

	result, err := suite.client.SendMessage(sendMsgExternal)
	suite.Require().NoError(err)

	res := suite.waitForReceiptOnShard(walletAddress.ShardId(), result)
	suite.Require().Equal(faucetAddress, res.ContractAddress)

	return walletAddress
}

func (suite *SuiteRpc) deployContract(address types.Address, code []byte, ownerPrivateKey *ecdsa.PrivateKey) types.Address {
	seqno, err := suite.client.GetTransactionCount(address, "latest")
	suite.Require().NoError(err)

	deployPayload := types.BuildDeployPayload(code, common.EmptyHash)
	deployMsgExternal := &types.ExternalMessage{
		Seqno:  seqno,
		To:     address,
		Data:   deployPayload.Bytes(),
		Deploy: true,
	}
	suite.Require().NoError(deployMsgExternal.Sign(ownerPrivateKey))

	result, err := suite.client.SendMessage(deployMsgExternal)
	suite.Require().NoError(err)

	res := suite.waitForReceiptOnShard(address.ShardId(), result)
	return res.ContractAddress
}

func (suite *SuiteRpc) TestCreateWalletViaFaucet() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)

	var value int64 = 100000
	walletAddress := suite.createWalletViaFaucet(userPrivateKey, value)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddress, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)

	suite.Require().NoError(err)
	suite.Require().Equal(uint64(value), balance.Uint64())
}

func (suite *SuiteRpc) TestDeployContractViaFaucetWithSend() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 1000000
	walletCode := suite.getWalletConstructorCode(userPublicKey)
	walletAddr := suite.sendViaFaucet(walletCode, userPrivateKey, *types.NewUint256(value))
	receiptContractAddress := suite.deployContract(walletAddr, walletCode, userPrivateKey)
	suite.Require().Equal(walletAddr, receiptContractAddress)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddr, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
}

func (suite *SuiteRpc) TestDeployContractViaFaucetWithWithdraw() {
	userPrivateKey, err := crypto.GenerateKey()
	suite.Require().NoError(err)
	userPublicKey := crypto.CompressPubkey(&userPrivateKey.PublicKey)

	var value uint64 = 1000000
	walletCode := suite.getWalletConstructorCode(userPublicKey)
	walletAddr := suite.withdrawFromFaucet(walletCode, userPrivateKey, *types.NewUint256(value))
	receiptContractAddress := suite.deployContract(walletAddr, walletCode, userPrivateKey)
	suite.Require().Equal(walletAddr, receiptContractAddress)

	blockNumber := transport.LatestBlockNumber
	balance, err := suite.client.GetBalance(walletAddr, transport.BlockNumberOrHash{BlockNumber: &blockNumber})
	suite.Require().NoError(err)
	suite.Require().Less(balance.Uint64(), value)
	suite.Require().Greater(balance.Uint64(), uint64(0))
}
